const { getSupabaseClient } = require('./_supabase');

const TABLE = process.env.EVENTS_TABLE || 'Event List';
const CONFLICT_COL = process.env.EVENTS_ON_CONFLICT || 'event_name_and_link';

// Table schema reference (create this in Supabase):
// create table if not exists events (
//   id bigint generated by default as identity primary key,
//   event_name text not null,
//   event_date text,
//   event_time text,
//   event_location text,
//   event_description text,
//   hosted_by text,
//   price text,
//   event_url text unique,
//   created_at timestamp with time zone default now()
// );

function withCompositeKey(events) {
  return (events || []).map((e) => ({
    ...e,
    // Create a stable unique composite key if column exists in table
    [CONFLICT_COL]: `${(e.event_name || '').trim()} | ${(e.event_url || '').trim()}`,
  }));
}

function sanitizeLikeValue(s) {
  if (!s || typeof s !== 'string') return '';
  // Remove characters that break PostgREST or-filters (commas, parentheses) and trim
  return s.replace(/[(),]/g, ' ').replace(/\s+/g, ' ').trim();
}

async function upsertEvents(supabase, events) {
  if (!Array.isArray(events) || events.length === 0) return { count: 0 };
  const rows = withCompositeKey(events);
  // Upsert on unique `event_url`
  const { data, error } = await supabase
    .from(TABLE)
    .upsert(rows, { onConflict: CONFLICT_COL })
    .select('event_url');
  if (error) throw error;
  return { count: data?.length || 0 };
}

async function fetchEvents(supabase, { q, limit = 100, maxLimit = 5000 }) {
  // Cap the limit at maxLimit to prevent excessive queries
  const actualLimit = Math.min(Number(limit) || 100, maxLimit);
  
  // For large limits, use batch fetching to handle Supabase's 1000 row limit
  if (actualLimit > 1000) {
    console.log(`Fetching ${actualLimit} events using batch method...`);
    const events = [];
    const batchSize = 1000;
    let offset = 0;
    
    while (events.length < actualLimit) {
      const remaining = actualLimit - events.length;
      const currentBatchSize = Math.min(batchSize, remaining);
      
      let query = supabase.from(TABLE).select('*').order('updated_at', { ascending: false });
      if (q) {
        const cleaned = sanitizeLikeValue(q);
        if (cleaned) {
          query = query.or(
            `event_name.ilike.%${cleaned}%,event_description.ilike.%${cleaned}%,event_location.ilike.%${cleaned}%,hosted_by.ilike.%${cleaned}%`
          );
        }
      }
      
      const { data, error } = await query.range(offset, offset + currentBatchSize - 1);
      if (error) throw error;
      
      if (!data || data.length === 0) break;
      events.push(...data);
      offset += currentBatchSize;
      
      console.log(`Fetched batch: ${data.length} events (total: ${events.length})`);
    }
    
    return events;
  } else {
    // For smaller limits, use regular query
    let query = supabase.from(TABLE).select('*').order('updated_at', { ascending: false });
    if (q) {
      const cleaned = sanitizeLikeValue(q);
      if (cleaned) {
        query = query.or(
          `event_name.ilike.%${cleaned}%,event_description.ilike.%${cleaned}%,event_location.ilike.%${cleaned}%,hosted_by.ilike.%${cleaned}%`
        );
      }
    }
    if (actualLimit) query = query.limit(actualLimit);
    const { data, error } = await query;
    if (error) throw error;
    return data || [];
  }
}

// Vercel-style default export handler
module.exports = async (req, res) => {
  const supabase = getSupabaseClient();

  try {
    if (req.method === 'GET') {
      const q = req.query.q || '';
      const limit = req.query.limit || 2000;
      const data = await fetchEvents(supabase, { q, limit, maxLimit: 5000 });
      return res.status(200).json({ ok: true, count: data.length, events: data });
    }

    if (req.method === 'POST') {
      // For POST requests, expect events data in the body to upsert
      const { events } = req.body || {};
      
      if (!Array.isArray(events) || events.length === 0) {
        return res.status(400).json({ 
          ok: false, 
          error: 'Expected events array in request body' 
        });
      }

      const { count } = await upsertEvents(supabase, events);
      return res.status(200).json({ ok: true, upserted: count });
    }

    res.setHeader('Allow', 'GET, POST');
    return res.status(405).json({ ok: false, error: 'Method Not Allowed' });
  } catch (err) {
    console.error(err);
    return res.status(500).json({ ok: false, error: err.message });
  }
};